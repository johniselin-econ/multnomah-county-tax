---------------------------------------------------------------
      name:  log_01
       log:  C:/Users/ji252/Documents/GitHub/multnomah-county-t
> ax/code/logs/01_log_data_clean_multnomah_2025-12-12.log
  log type:  text
 opened on:  12 Dec 2025, 16:18:31

. 
. //--------------------------------------------------
. // STEP -1: Acquire raw data (automated where possible)
. //--------------------------------------------------
. /*
> This block downloads public-use source data directly from off
> icial URLs if not present locally.
> 
> Automated downloads included:
>   - IRS SOI county-to-county migration: countyinflowYYZZ.csv 
> / countyoutflowYYZZ.csv
>   - IRS SOI county data: YYincyallagi.csv
>   - BEA Regional Economic Accounts (CAINC1): CAINC1.zip (unzi
> ps to CAINC1__ALL_AREAS_*.csv and related files)
> 
> Not automated here (authentication required):
>   - IPUMS NHGIS extract (nhgis0029) used below
>   - IPUMS USA microdata extract (usa_00152) used via "${code}
> ipums_code"
> To fully automate IPUMS downloads, you'll need to add an API-
> token-based workflow (IPUMS API).
> */
. 
. * Ensure expected directory structure exists
. capture mkdir "${data}"

. capture mkdir "${data}demographic"

. capture mkdir "${data}demographic/CAINC1"

. capture mkdir "${data}demographic/nhgis0029_csv"

. capture mkdir "${data}irs"

. 
end of do-file

. do "C:\Users\ji252\AppData\Local\Temp\STD7434_000002.tmp"

. /************************************************************
> *****************
> * Program:      ipums_api_download_usa.do
> * Purpose:      Download (and decompress) an IPUMS USA microd
> ata extract via IPUMS API v2
> *              - Intended to be called from your main cleanin
> g do-file before running IPUMS command code
> *
> * Requirements:
> *   1) Stata 16+ (Python integration enabled: "python query" 
> works)
> *   2) An IPUMS API key set as an environment variable:
> *        IPUMS_API_KEY
> *      (Key management is documented by IPUMS.) 
> *
> * Notes:
> *   - This script is written to download an EXISTING extract 
> number (default: 152 => usa_00152.*).
> *   - If you want to CREATE extracts via API (POST), see the 
> optional template at the bottom.
> *************************************************************
> ****************/
. 
. version 16.0

. 
. /*----------------------------
>   USER SETTINGS
> ----------------------------*/
. local ipums_collection    "usa"

. local ipums_version       2

. 
. * If your existing extract is usa_00152 (as referenced in you
> r project notes), this should be 152.
. local ipums_extract_num   152

. 
. * Where to stage the raw extract files (.dat, .xml, .do)
. * This matches your current workflow: cd "${data}acs/" then r
> un IPUMS code.
. local ipums_outdir        "${data}acs/"

. 
. * Polling controls (used only if the extract is not yet "comp
> leted")
. local ipums_poll_seconds  20

. local ipums_poll_max      180

. 
. 
. /*----------------------------
>   PRE-FLIGHT CHECKS
> ----------------------------*/
. capture noisily python query
---------------------------------------------------------------
    Python Settings
      set python_exec      C:\ProgramData\miniconda3\envs\ipums
> \python.exe
      set python_userpath  

    Python system information
      initialized          yes
      version              3.11.14
      architecture         64-bit
      library path         C:\ProgramData\miniconda3\envs\ipums
> \python311.dll

. if _rc {
.     di as error "Python integration is not available. This sc
> ript requires Stata 16+ with Python configured."
.     exit 198
. }

. 
. if "{ipums_key}" == "" {
.     di as error "Missing IPUMS_API_KEY environment variable."
.     di as error "Set IPUMS_API_KEY in your shell / OS environ
> ment (from your IPUMS account API key page) and re-run."
.     exit 198
. }

. 
. cap mkdir "`ipums_outdir'"

. 
. * Prefix and destination filenames (IPUMS convention: {collec
> tion}_{5-digit extract number})
. local ipums_extract_num5 : display %05.0f `ipums_extract_num'

. local ipums_extract_num5 : subinstr local ipums_extract_num5 
> " " "", all

. local ipums_prefix "`ipums_collection'_`ipums_extract_num5'"

. 
. local f_datagz "`ipums_outdir'`ipums_prefix'.dat.gz"

. local f_dat   "`ipums_outdir'`ipums_prefix'.dat"

. local f_xml   "`ipums_outdir'`ipums_prefix'.xml"

. local f_do    "`ipums_outdir'`ipums_prefix'.do"

. 
. * If already present, do nothing
. if (fileexists("`f_dat'") & fileexists("`f_xml'") & fileexist
> s("`f_do'")) {
.     di as txt "IPUMS files already present: `ipums_prefix' in
>  `ipums_outdir'"
.     exit
. }

. 
. 
. /*----------------------------
>   DOWNLOAD VIA IPUMS API (PYTHON)
> ----------------------------*/
. python:
----------------------------------------------- python (type en
> d to exit) --------------------------------------------------
>>> import json, os, sys, time, shutil, gzip
>>> from urllib.request import Request, urlopen
>>> from urllib.error import HTTPError, URLError
>>> 
>>> # Stata locals expanded into Python strings
... API_KEY     = r""""""
>>> COLLECTION  = r"""`ipums_collection'"""
>>> VERSION     = r"""`ipums_version'"""
>>> EXTRACT_NUM = int(r"""`ipums_extract_num'""")
>>> OUTDIR      = r"""`ipums_outdir'"""
>>> PREFIX      = r"""`ipums_prefix'"""
>>> POLL_S      = int(r"""`ipums_poll_seconds'""")
>>> POLL_MAX    = int(r"""`ipums_poll_max'""")
>>> 
>>> def api_get_json(url: str) -> dict:
...     req = Request(
...         url,
...         headers={
...             "Authorization": API_KEY,
...             "Content-Type": "application/json",
...         },
...         method="GET",
...     )
...     with urlopen(req) as resp:
...         return json.load(resp)
... 
>>> def download(url: str, out_path: str) -> None:
...     os.makedirs(os.path.dirname(out_path), exist_ok=True)
...     req = Request(url, headers={"Authorization": API_KEY}, 
> method="GET")
...     with urlopen(req) as resp, open(out_path, "wb") as f:
...         shutil.copyfileobj(resp, f)
... 
>>> def gunzip(in_path: str, out_path: str) -> None:
...     with gzip.open(in_path, "rb") as fin, open(out_path, "w
> b") as fout:
...         shutil.copyfileobj(fin, fout)
... 
>>> status_url = f"https://api.ipums.org/extracts/{EXTRACT_NUM}
> ?collection={COLLECTION}&version={VERSION}"
>>> 
>>> try:
...     obj = api_get_json(status_url)
... except HTTPError as e:
...     raise SystemExit(f"IPUMS API returned HTTP {e.code} for
>  {status_url}. "
...                      f"Verify the extract number and that t
> he API key has access.")
... except URLError as e:
...     raise SystemExit(f"Could not reach IPUMS API endpoint: 
> {e}")
... 
SystemExit: IPUMS API returned HTTP 401 for https://api.ipums.o
> rg/extracts/152?collection=usa&version=2. Verify the extract 
> number and that the API key has access.
>>> status = (obj.get("status") or "").lower()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'obj' is not defined
(43 lines skipped)
---------------------------------------------------------------
r(7102);

end of do-file

r(7102);

. do "C:\Users\ji252\AppData\Local\Temp\STD7434_000003.tmp"

. /************************************************************
> **************************************
> IPUMS API workflow from within Stata WITHOUT ipumspy / pandas
>  / numpy
> - Uses only Python standard library (urllib/json/gzip), which
>  is much less likely to crash Stata.
> - Supports:
>     (A) Download an existing extract by number; OR
>     (B) Create a new extract from a JSON definition file, pol
> l until completed, then download.
> 
> Requirements
> 1) Stata 16+ with Python integration configured (python set e
> xec "...python.exe")
> 2) IPUMS API key provided via the Stata local `ipums_api_key`
>  (see USER SETTINGS).
> 3) A JSON extract definition file if you want the "create" wo
> rkflow.
> 
> References: IPUMS Developer Portal (v2) microdata create-extr
> act workflow
> https://developer.ipums.org/docs/v2/workflows/create_extracts
> /microdata/
> *************************************************************
> *************************************/
. 
. version 19.0

. 
. /* ===========================
>    USER SETTINGS (EDIT THESE)
>    =========================== */
. 
. * Output directory for downloaded files (data + .do + .xml)
. * If you are using the Multnomah County project structure, th
> is likely already exists:
. *   global data "...";  -> then use "${data}acs"
. local outdir "${data}acs"

. 
. * IPUMS collection: "usa", "cps", "atus", etc.
. local collection "usa"

. 
. * Option 1: download an existing extract (set to a number, e.
> g. 152). Leave blank to create a new extract.
. local extract_number "152"

. 
. * Option 2: create a new extract from a JSON definition file 
> (only used if extract_number is blank)
. * IMPORTANT: The JSON must match the IPUMS API v2 schema for 
> microdata extracts.
. local extract_json_file "${code}ipums_extract_definition.json
> "

. 
. * Polling cadence / limits
. local poll_seconds 30

. local max_polls    240   // 240 * 30s = 2 hours

. 
. /* ===========================
>    END USER SETTINGS
>    =========================== */
. 
. capture mkdir "`outdir'"

. 
. python:
----------------------------------------------- python (type en
> d to exit) --------------------------------------------------
>>> import os, json, time, gzip, shutil
>>> from urllib.request import Request, urlopen
>>> from pathlib import Path
>>> 
>>> collection = r"""`collection'""".strip()
>>> outdir = Path(r"""`outdir'""")
>>> outdir.mkdir(parents=True, exist_ok=True)
>>> 
>>> extract_number = r"""`extract_number'""".strip()
>>> extract_json_file = r"""`extract_json_file'""".strip()
>>> poll_seconds = int(r"""`poll_seconds'""")
>>> max_polls = int(r"""`max_polls'""")
>>> 
>>> api_key = r"""$ipums_api_key""".strip()
>>> if not api_key:
...     raise RuntimeError("ipums_api_key Stata local is empty.
>  Set: local ipums_api_key \"...your key...\"")
... 
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
RuntimeError: ipums_api_key Stata local is empty. Set: local ip
> ums_api_key "...your key..."
(95 lines skipped)
---------------------------------------------------------------
r(7102);

end of do-file

r(7102);

. do "C:\Users\ji252\AppData\Local\Temp\STD7434_000004.tmp"

. 
. ** IPUMS Key 
. global ipums_key "59cba10d8a5da536fc06b59d6d6ae51613094627862
> c736d87e4430b"

. 
end of do-file

. do "C:\Users\ji252\AppData\Local\Temp\STD7434_000005.tmp"

. /************************************************************
> **************************************
> IPUMS API workflow from within Stata WITHOUT ipumspy / pandas
>  / numpy
> - Uses only Python standard library (urllib/json/gzip), which
>  is much less likely to crash Stata.
> - Supports:
>     (A) Download an existing extract by number; OR
>     (B) Create a new extract from a JSON definition file, pol
> l until completed, then download.
> 
> Requirements
> 1) Stata 16+ with Python integration configured (python set e
> xec "...python.exe")
> 2) IPUMS API key provided via the Stata local `ipums_api_key`
>  (see USER SETTINGS).
> 3) A JSON extract definition file if you want the "create" wo
> rkflow.
> 
> References: IPUMS Developer Portal (v2) microdata create-extr
> act workflow
> https://developer.ipums.org/docs/v2/workflows/create_extracts
> /microdata/
> *************************************************************
> *************************************/
. 
. version 19.0

. 
. /* ===========================
>    USER SETTINGS (EDIT THESE)
>    =========================== */
. 
. * Output directory for downloaded files (data + .do + .xml)
. * If you are using the Multnomah County project structure, th
> is likely already exists:
. *   global data "...";  -> then use "${data}acs"
. local outdir "${data}acs"

. 
. * IPUMS collection: "usa", "cps", "atus", etc.
. local collection "usa"

. 
. * Option 1: download an existing extract (set to a number, e.
> g. 152). Leave blank to create a new extract.
. local extract_number "152"

. 
. * Option 2: create a new extract from a JSON definition file 
> (only used if extract_number is blank)
. * IMPORTANT: The JSON must match the IPUMS API v2 schema for 
> microdata extracts.
. local extract_json_file "${code}ipums_extract_definition.json
> "

. 
. * Polling cadence / limits
. local poll_seconds 30

. local max_polls    240   // 240 * 30s = 2 hours

. 
. /* ===========================
>    END USER SETTINGS
>    =========================== */
. 
. capture mkdir "`outdir'"

. 
. python:
----------------------------------------------- python (type en
> d to exit) --------------------------------------------------
>>> import os, json, time, gzip, shutil
>>> from urllib.request import Request, urlopen
>>> from pathlib import Path
>>> 
>>> collection = r"""`collection'""".strip()
>>> outdir = Path(r"""`outdir'""")
>>> outdir.mkdir(parents=True, exist_ok=True)
>>> 
>>> extract_number = r"""`extract_number'""".strip()
>>> extract_json_file = r"""`extract_json_file'""".strip()
>>> poll_seconds = int(r"""`poll_seconds'""")
>>> max_polls = int(r"""`max_polls'""")
>>> 
>>> api_key = r"""$ipums_key""".strip()
>>> if not api_key:
...     raise RuntimeError("ipums_api_key Stata local is empty.
>  Set: local ipums_api_key \"...your key...\"")
... 
>>> BASE = "https://api.ipums.org"
>>> 
>>> def _request(method, url, body=None, headers=None):
...     h = {"Authorization": api_key}
...     if headers:
...         h.update(headers)
...     req = Request(url, data=body, headers=h, method=method)
...     return urlopen(req, timeout=120)
... 
>>> def create_extract_from_json(path):
...     p = Path(path)
...     if not p.exists():
...         raise FileNotFoundError(f"Extract JSON file not fou
> nd: {p}")
...     payload = p.read_text(encoding="utf-8")
...     url = f"{BASE}/extracts?collection={collection}&version
> =2"
...     with _request("POST", url, body=payload.encode("utf-8")
> , headers={"Content-Type": "application/json"}) as resp:
...         data = json.load(resp)
...     num = int(data["number"])
...     status = data.get("status")
...     print(f"[IPUMS] Submitted extract request. number={num}
> , status={status}")
...     return num
... 
>>> def get_extract_status(num):
...     url = f"{BASE}/extracts/{num}?collection={collection}&v
> ersion=2"
...     with _request("GET", url, headers={"Content-Type": "app
> lication/json"}) as resp:
...         return json.load(resp)
... 
>>> def download_file(url, dest):
...     dest.parent.mkdir(parents=True, exist_ok=True)
...     with _request("GET", url) as resp, open(dest, "wb") as 
> f:
...         shutil.copyfileobj(resp, f)
... 
>>> def maybe_gunzip(path_gz):
...     if path_gz.suffix.lower() != ".gz":
...         return path_gz
...     out_path = path_gz.with_suffix("")  # remove .gz
...     with gzip.open(path_gz, "rb") as f_in, open(out_path, "
> wb") as f_out:
...         shutil.copyfileobj(f_in, f_out)
...     return out_path
... 
... # Step 1: Determine extract number
>>> if extract_number:
...     num = int(extract_number)
...     print(f"[IPUMS] Using existing extract number={num}")
... else:
...     num = create_extract_from_json(extract_json_file)
... 
... # Step 2: Poll until completed
[IPUMS] Using existing extract number=152
>>> last_status = None
>>> status_obj = None
>>> for i in range(max_polls):
...     status_obj = get_extract_status(num)
...     status = status_obj.get("status")
...     if status != last_status:
...         print(f"[IPUMS] Extract {num} status: {status}")
...         last_status = status
... 
...     if status in ("failed", "canceled"):
...         raise RuntimeError(f"Extract {num} ended with statu
> s={status}. Full response: {status_obj}")
... 
...     if status == "completed" and status_obj.get("downloadLi
> nks"):
...         break
... 
...     time.sleep(poll_seconds)
... else:
...     raise TimeoutError(f"Timed out waiting for extract {num
> } to complete after {max_polls} polls.")
... 
[IPUMS] Extract 152 status: completed
Traceback (most recent call last):
  File "C:\ProgramData\miniconda3\envs\ipums\Lib\urllib\request
> .py", line 1348, in do_open
    h.request(req.get_method(), req.selector, req.data, headers
> ,
  File "C:\ProgramData\miniconda3\envs\ipums\Lib\http\client.py
> ", line 1303, in request
    self._send_request(method, url, body, headers, encode_chunk
> ed)
  File "C:\ProgramData\miniconda3\envs\ipums\Lib\http\client.py
> ", line 1349, in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
  File "C:\ProgramData\miniconda3\envs\ipums\Lib\http\client.py
> ", line 1298, in endheaders
    self._send_output(message_body, encode_chunked=encode_chunk
> ed)
  File "C:\ProgramData\miniconda3\envs\ipums\Lib\http\client.py
> ", line 1058, in _send_output
    self.send(msg)
  File "C:\ProgramData\miniconda3\envs\ipums\Lib\http\client.py
> ", line 996, in send
    self.connect()
  File "C:\ProgramData\miniconda3\envs\ipums\Lib\http\client.py
> ", line 1475, in connect
    self.sock = self._context.wrap_socket(self.sock,
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\ProgramData\miniconda3\envs\ipums\Lib\ssl.py", line 
> 517, in wrap_socket
    return self.sslsocket_class._create(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\ProgramData\miniconda3\envs\ipums\Lib\ssl.py", line 
> 1104, in _create
    self.do_handshake()
  File "C:\ProgramData\miniconda3\envs\ipums\Lib\ssl.py", line 
> 1382, in do_handshake
    self._sslobj.do_handshake()
ConnectionResetError: [WinError 10054] An existing connection w
> as forcibly closed by the remote host

During handling of the above exception, another exception occur
> red:

Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
  File "<stdin>", line 3, in get_extract_status
  File "<stdin>", line 6, in _request
  File "C:\ProgramData\miniconda3\envs\ipums\Lib\urllib\request
> .py", line 216, in urlopen
    return opener.open(url, data, timeout)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\ProgramData\miniconda3\envs\ipums\Lib\urllib\request
> .py", line 519, in open
    response = self._open(req, data)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\ProgramData\miniconda3\envs\ipums\Lib\urllib\request
> .py", line 536, in _open
    result = self._call_chain(self.handle_open, protocol, proto
> col +
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> ^^^^^
  File "C:\ProgramData\miniconda3\envs\ipums\Lib\urllib\request
> .py", line 496, in _call_chain
    result = func(*args)
             ^^^^^^^^^^^
  File "C:\ProgramData\miniconda3\envs\ipums\Lib\urllib\request
> .py", line 1391, in https_open
    return self.do_open(http.client.HTTPSConnection, req,
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\ProgramData\miniconda3\envs\ipums\Lib\urllib\request
> .py", line 1351, in do_open
    raise URLError(err)
urllib.error.URLError: <urlopen error [WinError 10054] An exist
> ing connection was forcibly closed by the remote host>
(28 lines skipped)
---------------------------------------------------------------
r(7102);

end of do-file

r(7102);

. do "C:\Users\ji252\AppData\Local\Temp\STD7434_000006.tmp"

. /************************************************************
> **************************************
> IPUMS API workflow from within Stata WITHOUT ipumspy / pandas
>  / numpy
> - Uses only Python standard library (urllib/json/gzip), which
>  is much less likely to crash Stata.
> - Supports:
>     (A) Download an existing extract by number; OR
>     (B) Create a new extract from a JSON definition file, pol
> l until completed, then download.
> 
> Requirements
> 1) Stata 16+ with Python integration configured (python set e
> xec "...python.exe")
> 2) IPUMS API key provided via the Stata local `ipums_api_key`
>  (see USER SETTINGS).
> 3) A JSON extract definition file if you want the "create" wo
> rkflow.
> 
> References: IPUMS Developer Portal (v2) microdata create-extr
> act workflow
> https://developer.ipums.org/docs/v2/workflows/create_extracts
> /microdata/
> *************************************************************
> *************************************/
. 
. version 19.0

. 
. /* ===========================
>    USER SETTINGS (EDIT THESE)
>    =========================== */
. 
. * Output directory for downloaded files (data + .do + .xml)
. * If you are using the Multnomah County project structure, th
> is likely already exists:
. *   global data "...";  -> then use "${data}acs"
. local outdir "${data}acs"

. 
. * IPUMS collection: "usa", "cps", "atus", etc.
. local collection "usa"

. 
. * Option 1: download an existing extract (set to a number, e.
> g. 152). Leave blank to create a new extract.
. local extract_number "152"

. 
. * Option 2: create a new extract from a JSON definition file 
> (only used if extract_number is blank)
. * IMPORTANT: The JSON must match the IPUMS API v2 schema for 
> microdata extracts.
. local extract_json_file "${code}ipums_extract_definition.json
> "

. 
. * Polling cadence / limits
. local poll_seconds 30

. local max_polls    240   // 240 * 30s = 2 hours

. 
. /* ===========================
>    END USER SETTINGS
>    =========================== */
. 
. capture mkdir "`outdir'"

. 
. python:
----------------------------------------------- python (type en
> d to exit) --------------------------------------------------
>>> import os, json, time, gzip, shutil
>>> from urllib.request import Request, urlopen
>>> from pathlib import Path
>>> 
>>> collection = r"""`collection'""".strip()
>>> outdir = Path(r"""`outdir'""")
>>> outdir.mkdir(parents=True, exist_ok=True)
>>> 
>>> extract_number = r"""`extract_number'""".strip()
>>> extract_json_file = r"""`extract_json_file'""".strip()
>>> poll_seconds = int(r"""`poll_seconds'""")
>>> max_polls = int(r"""`max_polls'""")
>>> 
>>> api_key = r"""$ipums_key""".strip()
>>> if not api_key:
...     raise RuntimeError("ipums_api_key Stata local is empty.
>  Set: local ipums_api_key \"...your key...\"")
... 
>>> BASE = "https://api.ipums.org"
>>> 
>>> def _request(method, url, body=None, headers=None):
...     h = {"Authorization": api_key}
...     if headers:
...         h.update(headers)
...     req = Request(url, data=body, headers=h, method=method)
...     return urlopen(req, timeout=120)
... 
>>> def create_extract_from_json(path):
...     p = Path(path)
...     if not p.exists():
...         raise FileNotFoundError(f"Extract JSON file not fou
> nd: {p}")
...     payload = p.read_text(encoding="utf-8")
...     url = f"{BASE}/extracts?collection={collection}&version
> =2"
...     with _request("POST", url, body=payload.encode("utf-8")
> , headers={"Content-Type": "application/json"}) as resp:
...         data = json.load(resp)
...     num = int(data["number"])
...     status = data.get("status")
...     print(f"[IPUMS] Submitted extract request. number={num}
> , status={status}")
...     return num
... 
>>> def get_extract_status(num):
...     url = f"{BASE}/extracts/{num}?collection={collection}&v
> ersion=2"
...     with _request("GET", url, headers={"Content-Type": "app
> lication/json"}) as resp:
...         return json.load(resp)
... 
>>> def download_file(url, dest):
...     dest.parent.mkdir(parents=True, exist_ok=True)
...     with _request("GET", url) as resp, open(dest, "wb") as 
> f:
...         shutil.copyfileobj(resp, f)
... 
>>> def maybe_gunzip(path_gz):
...     if path_gz.suffix.lower() != ".gz":
...         return path_gz
...     out_path = path_gz.with_suffix("")  # remove .gz
...     with gzip.open(path_gz, "rb") as f_in, open(out_path, "
> wb") as f_out:
...         shutil.copyfileobj(f_in, f_out)
...     return out_path
... 
... # Step 1: Determine extract number
>>> if extract_number:
...     num = int(extract_number)
...     print(f"[IPUMS] Using existing extract number={num}")
... else:
...     num = create_extract_from_json(extract_json_file)
... 
... # Step 2: Poll until completed
[IPUMS] Using existing extract number=152
>>> last_status = None
>>> status_obj = None
>>> for i in range(max_polls):
...     status_obj = get_extract_status(num)
...     status = status_obj.get("status")
...     if status != last_status:
...         print(f"[IPUMS] Extract {num} status: {status}")
...         last_status = status
... 
...     if status in ("failed", "canceled"):
...         raise RuntimeError(f"Extract {num} ended with statu
> s={status}. Full response: {status_obj}")
... 
...     if status == "completed" and status_obj.get("downloadLi
> nks"):
...         break
... 
...     time.sleep(poll_seconds)
... else:
...     raise TimeoutError(f"Timed out waiting for extract {num
> } to complete after {max_polls} polls.")
... 
[IPUMS] Extract 152 status: completed
